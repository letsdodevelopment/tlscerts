# Create tls certificate for internal traffic

## Step:01

Deploy app

```shell
oc create -f hello-app.yaml
oc expose deployment hello-app --port 8443

oc get svc -o wide
NAME        TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE   SELECTOR
hello-app   ClusterIP   10.217.4.100   <none>        8443/TCP   19m   app=hello-app
```

## Step: 02

Create a Secret

`oc annotate` is the main command, which I also now remember that I used to create cookie.

```shell
# here the assumption is, that name of the service is 'hello-app'

oc annotate service hello-app service.beta.openshift.io/serving-cert-secret-name=hello-app-secret

```

How to remember the annotation String?

- Secret-name is simply to remember, what i will forget is serving-cert. So, it is not serving-ca but 'serving-cert-secret-name'
- Service is as of today $(date) in beta. so is 'service.beta'



### Check the secret

Below is the JSON output and I'm trying to highlight that certificate is automatically generated and signed for you.

Importants points are

- certificate is for 24 months valid for the domain hello-app.tlscerts.svc and it provided by service-ca
- but our clients won't have this root CA certificate which is normally present in the browser.

```json
// oc get secret hello-app-secret -o json | jq .metadata.annotations

{
  "openshift.io/description": "Secret contains a pair signed serving certificate/key that is generated by Service CA operator for
  service/hello-app with hostname hello-app.tlscerts.svc and is annotated to the service with annotating a service resource with
  'service.beta.openshift.io/serving-cert-secret-name: hello-app-secret'. The certificate is valid for 2 years.",
  "openshift.io/owning-component": "service-ca",
  "service.alpha.openshift.io/expiry": "2027-07-23T16:57:19Z",
  "service.beta.openshift.io/expiry": "2027-07-23T16:57:19Z",
  "service.beta.openshift.io/originating-service-name": "hello-app",
  "service.beta.openshift.io/originating-service-uid": "90618df3-4b02-45c0-86f0-3ab2154a188d"
}
```

## Patch this Secret using patch file

Few things I learnt

- default path for the certificate (httpd) is /etc/httpd/tls/ and default certificate and keys are named as localhost.crt and localhost.key
- You can change this, but I'm not there yet
- review patch file especially volumes.secret.items. The path is where we define the name of the certificate and key.


oc patch deployment hello-app --patch-file patch-secret.yaml

### Test the right certificate is installed

```shell
oc exec -it hello-app-5bbc66d77b-728x8 -- openssl s_client -showcerts -connect hello-app.tlscerts.svc:8443
## OutPut ###
-----END CERTIFICATE-----
subject=CN=hello-app.tlscerts.svc
issuer=CN=openshift-service-serving-signer@1742136952
---
## OutPut ###

# Lets try with curl
oc exec -it hello-app-5bbc66d77b-728x8 -- curl https://hello-app.tlscerts.svc:8443
curl: (60) SSL certificate problem: self-signed certificate in certificate chain
More details here: https://curl.se/docs/sslcerts.html

curl failed to verify the legitimacy of the server and therefore could not
establish a secure connection to it. To learn more about this situation and
how to fix it, please visit the web page mentioned above.
command terminated with exit code 60
```

## Install CA certificate in a client and test it.

As the name is matching with the service, we are okay to go with the second steps.
I have deployed another test pod e.g. another httpd server and uploaded ca-chain into it.

### create a config map

oc create configmap ca-bundle

#### annotate config map 

oc annotate configmap ca-bundle service.beta.openshift.io/inject-cabundle=true

#### Check the config map

oc get configmap ca-bundle -o json

``` json
{
    "apiVersion": "v1",
    "data": {
        "service-ca.crt": "-----BEGIN CERTIFICATE-----\nMIIDUTCCAjmgAwIBAgIIJ3B1Gd9X1P4wDQYJKoZIhvcNAQELBQAwNjE0MDIGA1UE\nAwwrb3BlbnNoaWZ0LXNlcnZpY2Utc2VydmluZy1zaWduZXJAMTc0MjEzNjk1MjAe\nFw0yNTAzMTYxNDU1NTJaFw0yNzA1MTUxNDU1NTNaMDYxNDAyBgNVBAMMK29wZW5z\naGlmdC1zZXJ2aWNlLXNlcnZpbmctc2lnbmVyQDE3NDIxMzY5NTIwggEiMA0GCSqG\nSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDRBZw6tE5NRU8D/Y2SjayvPVfLL3Vhbsws\nX3wQllhE4i+LIx5CCcSrh+uhj/ugjJxCaagGZuke/cWhxsjb4J2neCVPL0oongcy\nK6CbqLHlokWAo/7EOEFcA3pPBg4ilkzBe7T6Aqv7c8hgm/+DPbULCnvvbYI1+9YW\n3AKwb2c/BaRW6BmU4xhSvzakrywyeOVDsdjKuPLvxetB9Cq7hQWY7kJSZ0zbU+0H\nUNh8s5GzzRF8ED0eBB25Yhwb8IPWLjA9InYbTV4bYAkC2z6TGDo+QPSsx99aWh2k\n573ycz84MdubZprR8rshD1oyP4tn4qYbflASWFiZTUi1QeKgbndDAgMBAAGjYzBh\nMA4GA1UdDwEB/wQEAwICpDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRNsoGA\n030DfMXwKZxYOU4oI2axvDAfBgNVHSMEGDAWgBRNsoGA030DfMXwKZxYOU4oI2ax\nvDANBgkqhkiG9w0BAQsFAAOCAQEAeXLUySlxxngcay0kLO7bqVETnrxNnrDAYd0e\nZ85n+9QbfHbiD3GFdhMst9e5qQ1ECmCEavezNKw66mA9zstN/AJhGHw/uTs3XsYc\nuHFmze3fr0cf0I/479kCaJE4HGyt3wwSOpmgAhwhsdIkmIEzaxRDYLhOLVHBR7YE\n/XTSM3zVIc+qwkIx9MzXzL563W3AXROfuYvaiJeA2IE+t0UsPJ/t28L4BDAIMoZ/\nXY//OtUH+N3d6ACbspRbTgWcOlJr5rKyiYXrA6eDAqc75DJkyTWB5KSclQH6BWV6\nmplV7q8VGdqgq42h3eD2MvAoQt3sz79C4RbSwBwKmAMD1Dhnfw==\n-----END CERTIFICATE-----\n"
    },
    "kind": "ConfigMap",
    "metadata": {
        "annotations": {
            "openshift.io/description": "Configmap is added/updated with a data item containing the CA signing bundle that can be used to verify service-serving certificates",
            "openshift.io/owning-component": "service-ca",
            "service.beta.openshift.io/inject-cabundle": "true"
        },
        "creationTimestamp": "2025-07-24T08:42:19Z",
        "name": "ca-bundle",
        "namespace": "tlscerts",
        "resourceVersion": "2692465",
        "uid": "05e18439-0926-4547-af89-46f0b177070a"
    }
}
```

Important fields are

- name of the ca certificate is service-ca.crt


All we need is to add this information to the manifest file. I can as well create a patch file. But lets keep it simple. 

### volumeMounts

Add volumeMounts information. The destination for copy ca bundle should be known before. I can say, nginx and httpd have same location.

### volumes

In this section, we have add config map information esp the thing under items. Here we need name of the key ie. service-ca.crt and name of the file should be mentioned in the path.
and ensure the configmap name matches with you created earlier

oc create -f sampleapp.yaml

and then repeat the same command we did earlier but this time from sample-app and both the results should be successful i.e. without any self signed certificates warning message

```shell

oc exec -it sample-app-6657c95f6d-wjb8k -- openssl s_client -showcerts -connect hello-app.tlscerts.svc:8443 -msg
oc exec -it sample-app-6657c95f6d-wjb8k -- curl https://hello-app.tlscerts.svc:8443
```

